#

**这个题目是一个一眼看上去像贪心**
**实际上这个题目可以用动态规划，可以用DFS，也可以用BFS,但是不能贪心**


## 首先我们分析一下,为什么我知道不是贪心?
---
#### 来来来，我们回顾一下!

##### 贪心算法的核心是什么？
```
核心是我可以选择一个局部最优解，但是b不一定是全局最优解
```
##### 那我怎么知道不能局部推全局呢？
- 最直接的方法当然是找反例

```
你贪心地向着目标移动,但是有时候可是会进"死胡同"啊!!
这就是客观事实，这就是我们的依据
```
- 那最自然的思路呢?
```
遇到可行路径问题,一定第一反应向着DP与图论想，因为他是解决最优化问题非常优雅的数学模型
```
- DP 与图论那个又更好呢
  **答案是各有优缺点**


| **算法**     | **时间复杂度**       | **空间复杂度**     | **优缺点**                          | **适用场景**                      |
|--------------|----------------------|--------------------|-------------------------------------|-----------------------------------|
| **DFS**      | 指数级 \(O(2^{n \times m})\)  | 递归栈开销            | 简单实现，适合小规模矩阵；栈溢出风险 | 小规模矩阵，简单判断问题         |
| **BFS**      | \(O(n \times m)\)    | \(O(n \times m)\)   | 避免栈溢出，找最短路径；队列开销大  | 路径长度要求，避免递归问题       |
| **DP**       | \(O(n \times m)\)    | \(O(n \times m)\)   | 避免重复计算，代码简洁；无法还原路径 | 可达性问题，路径长度不重要       |
| **并查集**   | \(O(n \times m \cdot \alpha(n \times m))\) | \(O(n \times m)\)   | 性能高效，适合稀疏矩阵；实现复杂   | 频繁连通性判断，稀疏矩阵场景     |

#### **总结推荐**  
- **小规模矩阵**：选择 **DFS**。
- **大规模矩阵**：优先 **BFS**（路径问题）或 **DP**（可达性）。
- **稀疏矩阵**：使用 **并查集** 处理连通性问题。
---
#### 大的思路引导我们已经找到了本质，接下来就是具体分析

- **动态规划**
  - 第一步:转移方程
      - 
