
# 模拟 

#### STL熟练 + 善用库

# 动态规划

- 在动态规划中，关键在于能否通过局部最优推导出全局最优，即状态转移方程。
- 问题可以由多种维度组合解决，因此 DP 维度的选取至关重要。
- 本文将讲解 01 背包的二维 DP 及其使用滚动数组优化后的 一维 DP，并在最后做总结。

### 拆解问题

- 可能的状态包括：
  - 第 i 个物品的选择情况：\(2^n\)
  - 每个物品的价值
  - 每个物品的重量
  - 初始背包容量

### 状态转移

我们需要找到独立的维度，并尝试建立转移关系。如果我们的目标是将局部最优作为对应目标，可以有：

- 前 n 个物品当前背包总占用空间
- 前 n 个物品当前背包剩余空间
- 当前空间为 S

### 局部最优与全局最优

在 01 背包问题中，可以先采用贪心的方式思考局部最优的选择。

每一步的最优选择是上一步可能导致它的最优解集合中的最优。

## 二、代码实现

### 1. 二维 DP

以下代码展示了使用二维 DP 的实现。

```cpp
#include <iostream>
#include <algorithm> // For std::max
#define MaxBag 1005
#define MaxNum 1005
#define ll long long 

using namespace std;

ll dp(int n, int s) {
    ll DP[MaxNum][MaxBag] = {0}; // 二维 DP 数组
    int weight, value;

    for (int i = 0; i < n; i++) {
        cin >> weight >> value; // 输入每个物品的重量和价值
        for (int j = s; j >= 0; j--) {
            if (j >= weight) {
                DP[i + 1][j] = max(DP[i][j], DP[i][j - weight] + value); // 状态转移方程
            } else {
                DP[i + 1][j] = DP[i][j]; // 物品无法放入当前背包容量
            }
        }
    }
    return DP[n][s]; // 返回最大价值
}

```

### 2. 一维 DP

使用滚动数组优化的实现如下：

```cpp
#include <iostream>
#include <algorithm> // For std::max
#define MaxBag 1005
#define ll long long 

using namespace std;

ll optimizedDp(int n, int s) {
    ll DP[MaxBag + 1] = {0}; // 记录每个背包容量下的最大价值
    int weight, value;

    for (int i = 0; i < n; i++) {
        cin >> weight >> value; // 输入每个物品的重量和价值
        for (int j = s; j >= weight; j--) {
            DP[j] = max(DP[j], DP[j - weight] + value); // 动态规划状态转移方程
        }
    }
    return DP[s]; // 返回最大价值
}

```

## 三、总结

- 01 背包问题是动态规划中的经典问题，通过合理的状态转移和维度选择，可以有效解决。
- 二维 DP 实现虽然直观，但空间复杂度较高；使用滚动数组优化后，可以显著减少空间占用，提升效率。



# 数论




### 1. **质数与素数筛选**
- 质数判断
```cpp
bool isPrime(int n) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;
    for (int i = 5; i * i <= n; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) return false;
    }
    return true;
}
```
- 埃拉托斯特尼筛法（Sieve of Eratosthenes）
```cpp

void sieve(int max_n, vector<int>& primes) {
    vector<bool> is_prime(max_n + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int p = 2; p * p <= max_n; ++p) {
        if (is_prime[p]) {
            for (int i = p * p; i <= max_n; i += p) {
                is_prime[i] = false;
            }
        }
    }
    for (int p = 2; p <= max_n; ++p) {
        if (is_prime[p]) {
            primes.push_back(p);
        }
    }
}

```

### 2. **最大公约数与最小公倍数**
- 欧几里得算法（最大公约数）
```cpp

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```
- **最小公倍数**
```cpp

int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```
### 3. **扩展欧几里得算法**
- 扩展欧几里得算法
```cpp

tuple<int, int, int> extendedGCD(int a, int b) {
    if (b == 0) return {a, 1, 0};
    auto [d, x1, y1] = extendedGCD(b, a % b);
    return {d, y1, x1 - (a / b) * y1};
}
```
### 4. **模运算**
- 模逆元素
```cpp

int modInverse(int a, int m) {
    auto [g, x, y] = extendedGCD(a, m);
    if (g != 1) return -1; // 无逆元素
    return (x % m + m) % m;
}
```
- 中国剩余定理
```cpp

tuple<int, int> chineseRemainderTheorem(const vector<int>& a, const vector<int>& m) {
    int n = a.size();
    int M = 1;
    for (int mi : m) M *= mi;
    int x = 0;
    for (int i = 0; i < n; ++i) {
        int Mi = M / m[i];
        int mi_inv = modInverse(Mi, m[i]);
        x = (x + a[i] * Mi * mi_inv) % M;
    }
    return {x, M};
}
```
### 5. **指数与对数**
- 快速幂
```cpp

int modPow(int base, int exp, int mod) {
    int result = 1;
    while (exp > 0) {
        if (exp % 2 == 1) result = (result * base) % mod;
        base = (base * base) % mod;
        exp /= 2;
    }
    return result;
}
```
- 费马小定理
```cpp

int fermatLittleTheorem(int a, int p) {
    return modPow(a, p - 1, p);
}
```
### 6. **整数分解与约数**
- 整数分解（暴力）
```cpp

vector<int> primeFactors(int n) {
    vector<int> factors;
    while (n % 2 == 0) {
        factors.push_back(2);
        n /= 2;
    }
    for (int i = 3; i * i <= n; i += 2) {
        while (n % i == 0) {
            factors.push_back(i);
            n /= i;
        }
    }
    if (n > 2) factors.push_back(n);
    return factors;
}
```
- 求约数
```cpp
vector<int> divisors(int n) {
    vector<int> divs;
    for (int i = 1; i * i <= n; ++i) {
        if (n % i == 0) {
            divs.push_back(i);
            if (i != n / i) divs.push_back(n / i);
        }
    }
    return divs;
}
```
### 7. **模方程与同余**
- 同余方程求解
```cpp
bool solveCongruence(int a, int b, int m, int &x) {
    int g = gcd(a, m);
    if (b % g != 0) return false;
    a /= g;
    b /= g;
    m /= g;
    x = (modInverse(a, m) * b) % m;
    if (x < 0) x += m;
    return true;
}
```
### 8. **其他**
- 确定性 Miller-Rabin 质数检测
```cpp
bool millerRabin(int n, int k) {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0) return false;

    int r = 0, d = n - 1;
    while (d % 2 == 0) {
        d /= 2;
        ++r;
    }

    auto isComposite = [&](int a) {
        int x = modPow(a, d, n);
        if (x == 1 || x == n - 1) return false;
        for (int i = 0; i < r - 1; ++i) {
            x = modPow(x, 2, n);
            if (x == n - 1) return false;
        }
        return true;
    };

    for (int i = 0; i < k; ++i) {
        int a = rand() % (n - 1) + 1;
        if (isComposite(a)) return false;
    }
    return true;
}
```







# 排序算法




## 算法实现

### 1. 冒泡排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void bubbleSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]); // 交换元素
            }
        }
    }
}
```

### 2. 选择排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void selectionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 找到最小元素
            }
        }
        swap(arr[i], arr[minIndex]); // 交换到当前位置
    }
}
```

### 3. 插入排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void insertionSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 移动元素
            j--;
        }
        arr[j + 1] = key; // 插入元素
    }
}
```

### 4. 快速排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // 选择最后一个元素为基准
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]); // 交换元素
        }
    }
    swap(arr[i + 1], arr[high]); // 将基准放到正确位置
    return i + 1; // 返回基准的索引
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high); // 划分
        quickSort(arr, low, pi - 1); // 左边递归
        quickSort(arr, pi + 1, high); // 右边递归
    }
}
```

### 5. 归并排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1; // 左半部分的大小
    int n2 = right - mid; // 右半部分的大小
    vector<int> L(n1), R(n2); // 创建临时数组

    for (int i = 0; i < n1; i++) L[i] = arr[left + i]; // 复制左半部分
    for (int i = 0; i < n2; i++) R[i] = arr[mid + 1 + i]; // 复制右半部分

    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k++] = L[i++]; // 选择较小的元素
        } else {
            arr[k++] = R[j++];
        }
    }
    while (i < n1) arr[k++] = L[i++]; // 复制剩余元素
    while (j < n2) arr[k++] = R[j++]; // 复制剩余元素
}

void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2; // 找到中间索引
        mergeSort(arr, left, mid); // 左边递归
        mergeSort(arr, mid + 1, right); // 右边递归
        merge(arr, left, mid, right); // 合并
    }
}
```

### 6. 堆排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void heapify(vector<int>& arr, int n, int i) {
    int largest = i; // 初始化最大值为根节点
    int left = 2 * i + 1; // 左子节点
    int right = 2 * i + 2; // 右子节点

    if (left < n && arr[left] > arr[largest]) largest = left; // 左子节点更大
    if (right < n && arr[right] > arr[largest]) largest = right; // 右子节点更大

    if (largest != i) {
        swap(arr[i], arr[largest]); // 交换
        heapify(arr, n, largest); // 递归堆化
    }
}

void heapSort(vector<int>& arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i); // 构建堆
    for (int i = n - 1; i >= 0; i--) {
        swap(arr[0], arr[i]); // 交换堆顶和末尾元素
        heapify(arr, i, 0); // 堆化
    }
}
```

### 7. 计数排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

void countingSort(vector<int>& arr) {
    int n = arr.size();
    int maxVal = *max_element(arr.begin(), arr.end()); // 找到最大值
    vector<int> count(maxVal + 1, 0); // 计数数组

    for (int i = 0; i < n; i++) {
        count[arr[i]]++; // 计数
    }

    for (int i = 1; i <= maxVal; i++) {
        count[i] += count[i - 1]; // 累加
    }

    vector<int> output(n);
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i]; // 按照计数填入输出数组
        count[arr[i]]--;
    }

    for (int i = 0; i < n; i++) {
        arr[i] = output[i]; // 更新原数组
    }
}
```

### 8. 基数排序

```cpp
#include <iostream>
#include <vector>
using namespace std;

int getMax(const vector<int>& arr) {
    return *max_element(arr.begin(), arr.end()); // 获取数组中的最大值
}

void countingSortForRadix(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n);
    int count[10] = {0}; // 基数为10

    for (int i = 0; i < n; i++) {
        count[(arr[i] / exp) % 10]++; // 计数
    }

    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1]; // 累加
    }

    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i]; // 填入输出数组
        count[(arr[i] / exp) % 10]--;
    }

    for (int i = 0; i < n; i++) {
        arr[i] = output[i]; // 更新原数组
    }
}

void radixSort(vector<int>& arr) {
    int maxVal = getMax(arr); // 找到最大值
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        countingSortForRadix(arr, exp); // 对每个数字进行计数排序
    }
}
```



# 图论


## 二、常见图论算法实现

### 1. 深度优先搜索 (DFS)

```cpp
#include <iostream>
#include <vector>
using namespace std;

void dfs(int node, vector<bool>& visited, const vector<vector<int>>& graph) {
    visited[node] = true; // 标记当前节点为已访问
    cout << node << " "; // 处理当前节点

    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            dfs(neighbor, visited, graph); // 递归访问未访问的邻居
        }
    }
}
```

### 2. 广度优先搜索 (BFS)

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

void bfs(int start, const vector<vector<int>>& graph) {
    vector<bool> visited(graph.size(), false); // 访问标记
    queue<int> q; // 队列
    visited[start] = true; // 标记起始节点为已访问
    q.push(start); // 将起始节点入队

    while (!q.empty()) {
        int node = q.front(); // 获取队头节点
        q.pop(); // 出队
        cout << node << " "; // 处理当前节点

        for (int neighbor : graph[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true; // 标记为已访问
                q.push(neighbor); // 入队
            }
        }
    }
}
```

### 3. Dijkstra 算法（最短路径）

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <limits>
using namespace std;

vector<int> dijkstra(int start, const vector<vector<pair<int, int>>& graph) {
    vector<int> distance(graph.size(), numeric_limits<int>::max()); // 距离数组
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // 最小优先队列
    distance[start] = 0; // 起始节点距离为 0
    pq.push({0, start}); // 将起始节点入队

    while (!pq.empty()) {
        int node = pq.top().second; // 获取当前节点
        int dist = pq.top().first; // 当前节点的距离
        pq.pop(); // 出队

        if (dist > distance[node]) continue; // 如果当前距离大于已知距离，跳过

        for (const auto& neighbor : graph[node]) {
            int nextNode = neighbor.first;
            int weight = neighbor.second;
            if (distance[node] + weight < distance[nextNode]) {
                distance[nextNode] = distance[node] + weight; // 更新距离
                pq.push({distance[nextNode], nextNode}); // 入队
            }
        }
    }
    return distance; // 返回最短路径数组
}
```

### 4. Kruskal 算法（最小生成树）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Edge {
    int u, v, weight; // 边的两个端点和权重
};

bool compare(Edge a, Edge b) {
    return a.weight < b.weight; // 按权重排序
}

int find(int node, vector<int>& parent) {
    if (parent[node] != node) {
        parent[node] = find(parent[node], parent); // 路径压缩
    }
    return parent[node];
}

void kruskal(int n, vector<Edge>& edges) {
    sort(edges.begin(), edges.end(), compare); // 排序边
    vector<int> parent(n);
    for (int i = 0; i < n; i++) parent[i] = i; // 初始化并查集

    vector<Edge> mst; // 存储最小生成树的边
    for (const auto& edge : edges) {
        int uRoot = find(edge.u, parent);
        int vRoot = find(edge.v, parent);
        if (uRoot != vRoot) {
            mst.push_back(edge); // 添加到最小生成树
            parent[uRoot] = vRoot; // 合并集合
        }
    }

    // 输出最小生成树的边
    for (const auto& edge : mst) {
        cout << edge.u << " - " << edge.v << " : " << edge.weight << endl;
    }
}
```

# 计算几何




## 算法实现

### 1. 点与线段的关系

判断一个点是否在线段上：

```cpp
#include <iostream>
using namespace std;

struct Point {
    int x, y;
};

// 判断点p是否在以a和b为端点的线段上
bool onSegment(Point p, Point a, Point b) {
    return (p.x <= max(a.x, b.x) && p.x >= min(a.x, b.x) &&
            p.y <= max(a.y, b.y) && p.y >= min(a.y, b.y));
}

// 计算向量叉积
int crossProduct(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

// 判断点p与线段ab的关系
bool pointOnSegment(Point p, Point a, Point b) {
    int cp = crossProduct(a, b, p);
    if (cp == 0) { // 共线
        return onSegment(p, a, b);
    }
    return false;
}
```

### 2. 凸包（Graham 扫描）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

struct Point {
    int x, y;
};

// 比较函数，用于排序
bool compare(Point a, Point b) {
    return a.y < b.y || (a.y == b.y && a.x < b.x);
}

// 计算向量叉积
int crossProduct(Point a, Point b, Point c) {
    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}

// Graham 扫描算法
vector<Point> convexHull(vector<Point>& points) {
    sort(points.begin(), points.end(), compare);
    vector<Point> hull;

    // 下半部分
    for (const auto& p : points) {
        while (hull.size() >= 2 && crossProduct(hull[hull.size() - 2], hull.back(), p) <= 0) {
            hull.pop_back();
        }
        hull.push_back(p);
    }

    // 上半部分
    size_t t = hull.size() + 1;
    for (int i = points.size() - 1; i >= 0; i--) {
        while (hull.size() >= t && crossProduct(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {
            hull.pop_back();
        }
        hull.push_back(points[i]);
    }
    
    hull.pop_back(); // 去除最后一个点，避免重复
    return hull;
}
```

### 3. 线段交点

```cpp
#include <iostream>
using namespace std;

struct Point {
    int x, y;
};

bool onSegment(Point p, Point q, Point r) {
    return (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&
            q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y));
}

// 计算向量叉积
int orientation(Point p, Point q, Point r) {
    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    if (val == 0) return 0; // collinear
    return (val > 0) ? 1 : 2; // clock or counterclock wise
}

// 判断两条线段是否相交
bool doIntersect(Point p1, Point q1, Point p2, Point q2) {
    int o1 = orientation(p1, q1, p2);
    int o2 = orientation(p1, q1, q2);
    int o3 = orientation(p2, q2, p1);
    int o4 = orientation(p2, q2, q1);

    if (o1 != o2 && o3 != o4) return true; // 普通情况
    if (o1 == 0 && onSegment(p1, p2, q1)) return true; // p2在p1q1上
    if (o2 == 0 && onSegment(p1, q2, q1)) return true; // q2在p1q1上
    if (o3 == 0 && onSegment(p2, p1, q2)) return true; // p1在p2q2上
    if (o4 == 0 && onSegment(p2, q1, q2)) return true; // q1在p2q2上

    return false; // 不相交
}
```

### 4. 最近点对

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

struct Point {
    int x, y;
};

double distance(Point p1, Point p2) {
    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}

// 计算最小距离
double closestPairUtil(vector<Point>& pointsX, vector<Point>& pointsY) {
    int n = pointsX.size();
    if (n <= 3) {
        double minDist = DBL_MAX;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                minDist = min(minDist, distance(pointsX[i], pointsX[j]));
        return minDist;
    }

    int mid = n / 2;
    Point midPoint = pointsX[mid];

    vector<Point> pointsYLeft, pointsYRight;
    for (auto p : pointsY) {
        if (p.x <= midPoint.x) pointsYLeft.push_back(p);
        else pointsYRight.push_back(p);
    }

    double d1 = closestPairUtil(pointsX, pointsYLeft);
    double d2 = closestPairUtil(pointsX, pointsYRight);
    double d = min(d1, d2);

    vector<Point> strip;
    for (auto p : pointsY) {
        if (abs(p.x - midPoint.x) < d) strip.push_back(p);
    }

    for (int i = 0; i < strip.size(); i++)
        for (int j = i + 1; j < strip.size() && (strip[j].y - strip[i].y) < d; j++)
            d = min(d, distance(strip[i], strip[j]));

    return d;
}

double closestPair(vector<Point>& points) {
    vector<Point> pointsX = points, pointsY = points;
    sort(pointsX.begin(), pointsX.end(), [](Point a, Point b) { return a.x < b.x; });
    sort(pointsY.begin(), pointsY.end(), [](Point a, Point b) { return a.y < b.y; });
    return closestPairUtil(pointsX, pointsY);
}
```

## 三、总结

- 计算几何算法提供了处理几何问题的有效方法，适用于图形学、机器人、GIS等领域。
- 了解基本的几何关系和算法实现，可以帮助解决更复杂的几何问题。


# 思维训练



### 1. **遍历技巧**
   - **滑动窗口**：处理连续子数组或子串。
   - **双指针**：在数组中寻找特定条件的元素。

### 2. **选择策略**
   - **贪心策略**：每步选择局部最优解。
   - **动态规划**：通过分解问题和优化已有解。

### 3. **搜索与回溯**
   - **回溯法**：尝试所有可能解，逐步回退。
   - **分治策略**：将问题分解为小子问题。

### 4. **数据处理**
   - **前缀和**：快速计算区间和。
   - **区间合并**：处理重叠区间。

### 5. **状态管理**
   - **状态压缩**：使用位运算优化状态表示。
   - **位运算技巧**：高效处理数值操作。

### 6. **特定问题技巧**
   - **图论技巧**：如最小生成树、拓扑排序等策略。
